{
  "language": "Solidity",
  "sources": {
    "src/EOFeedManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport { IPauserRegistry } from \"eigenlayer-contracts/interfaces/IPauserRegistry.sol\";\nimport { IEOFeedVerifier } from \"./interfaces/IEOFeedVerifier.sol\";\nimport { IEOFeedManager } from \"./interfaces/IEOFeedManager.sol\";\nimport {\n    InvalidAddress,\n    CallerIsNotWhitelisted,\n    MissingLeafInputs,\n    FeedNotSupported,\n    InvalidInput,\n    CallerIsNotPauser,\n    CallerIsNotUnpauser,\n    CallerIsNotFeedDeployer\n} from \"./interfaces/Errors.sol\";\n\n/**\n * @title EOFeedManager\n * @author eOracle\n * @notice The EOFeedManager contract is responsible for receiving feed updates from whitelisted publishers. These\n * updates are verified using the logic in the EOFeedVerifier. Upon successful verification, the feed data is stored in\n * the EOFeedManager and made available for other smart contracts to read. Only supported feed IDs can be published to\n * the feed manager.\n */\ncontract EOFeedManager is IEOFeedManager, OwnableUpgradeable, PausableUpgradeable {\n    /// @dev Map of feed id to price feed (feed id => PriceFeed)\n    mapping(uint256 => PriceFeed) internal _priceFeeds;\n\n    /// @dev Map of whitelisted publishers (publisher => is whitelisted)\n    mapping(address => bool) internal _whitelistedPublishers;\n\n    /// @dev Map of supported feeds, (feed id => is supported)\n    mapping(uint256 => bool) internal _supportedFeedIds;\n\n    /// @dev feed verifier contract\n    IEOFeedVerifier internal _feedVerifier;\n\n    /// @notice Address of the `PauserRegistry` contract that this contract defers to for determining access control\n    /// (for pausing).\n    IPauserRegistry internal _pauserRegistry;\n\n    /// @dev Address of the feed deployer\n    address internal _feedDeployer;\n\n    /* ============ Modifiers ============ */\n\n    /// @dev Allows only whitelisted publishers to call the function\n    modifier onlyWhitelisted() {\n        if (!_whitelistedPublishers[msg.sender]) revert CallerIsNotWhitelisted(msg.sender);\n        _;\n    }\n\n    /// @dev Allows only non-zero addresses\n    modifier onlyNonZeroAddress(address addr) {\n        if (addr == address(0)) revert InvalidAddress();\n        _;\n    }\n\n    modifier onlyPauser() {\n        if (!_pauserRegistry.isPauser(msg.sender)) revert CallerIsNotPauser();\n        _;\n    }\n\n    modifier onlyUnpauser() {\n        if (msg.sender != _pauserRegistry.unpauser()) revert CallerIsNotUnpauser();\n        _;\n    }\n\n    modifier onlyFeedDeployer() {\n        if (msg.sender != _feedDeployer) revert CallerIsNotFeedDeployer();\n        _;\n    }\n\n    /* ============ Constructor ============ */\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /* ============ Initializer ============ */\n\n    /**\n     * @notice Initialize the contract with the feed verifier address\n     * @dev The feed verifier contract must be deployed first\n     * @param feedVerifier Address of the feed verifier contract\n     * @param owner Owner of the contract\n     * @param pauserRegistry Address of the pauser registry contract\n     * @param feedDeployer Address of the feed deployer\n     */\n    function initialize(\n        address feedVerifier,\n        address owner,\n        address pauserRegistry,\n        address feedDeployer\n    )\n        external\n        onlyNonZeroAddress(feedVerifier)\n        onlyNonZeroAddress(feedDeployer)\n        onlyNonZeroAddress(pauserRegistry)\n        initializer\n    {\n        __Ownable_init(owner);\n        __Pausable_init();\n        _feedVerifier = IEOFeedVerifier(feedVerifier);\n        _pauserRegistry = IPauserRegistry(pauserRegistry);\n        _feedDeployer = feedDeployer;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @notice Set the feed verifier contract address\n     * @param feedVerifier Address of the feed verifier contract\n     */\n    function setFeedVerifier(address feedVerifier) external onlyOwner onlyNonZeroAddress(feedVerifier) {\n        _feedVerifier = IEOFeedVerifier(feedVerifier);\n        emit FeedVerifierSet(feedVerifier);\n    }\n\n    /**\n     * @notice Set the feed deployer\n     * @param feedDeployer The feed deployer address\n     */\n    function setFeedDeployer(address feedDeployer) external onlyOwner onlyNonZeroAddress(feedDeployer) {\n        _feedDeployer = feedDeployer;\n        emit FeedDeployerSet(feedDeployer);\n    }\n\n    /**\n     * @notice Reset timestamps for specified price feeds to zero\n     * @dev This function can only be called by the contract owner\n     * @dev Useful for emergency situations where you need to clear stale timestamp data\n     * @param feedIds Array of feed IDs whose timestamps should be reset\n     */\n    function resetFeedTimestamps(uint256[] calldata feedIds) external onlyOwner {\n        for (uint256 i = 0; i < feedIds.length; i++) {\n            uint256 feedId = feedIds[i];\n            if (!_supportedFeedIds[feedId]) {\n                revert FeedNotSupported(feedId);\n            }\n            _priceFeeds[feedId].timestamp = 0;\n        }\n    }\n    /**\n     * @notice Set the supported feeds\n     * @param feedIds Array of feed ids\n     * @param isSupported Array of booleans indicating whether the feed is supported\n     */\n\n    function setSupportedFeeds(uint256[] calldata feedIds, bool[] calldata isSupported) external onlyOwner {\n        if (feedIds.length != isSupported.length) revert InvalidInput();\n        for (uint256 i = 0; i < feedIds.length; i++) {\n            _supportedFeedIds[feedIds[i]] = isSupported[i];\n            emit SupportedFeedsUpdated(feedIds[i], isSupported[i]);\n        }\n    }\n\n    /**\n     * @notice Add supported feeds\n     * @param feedIds Array of feed ids\n     */\n    function addSupportedFeeds(uint256[] calldata feedIds) external onlyFeedDeployer {\n        for (uint256 i = 0; i < feedIds.length; i++) {\n            _supportedFeedIds[feedIds[i]] = true;\n            emit SupportedFeedsUpdated(feedIds[i], true);\n        }\n    }\n\n    /**\n     * @inheritdoc IEOFeedManager\n     */\n    function whitelistPublishers(address[] calldata publishers, bool[] calldata isWhitelisted) external onlyOwner {\n        if (publishers.length != isWhitelisted.length) revert InvalidInput();\n        for (uint256 i = 0; i < publishers.length; i++) {\n            if (publishers[i] == address(0)) revert InvalidAddress();\n            _whitelistedPublishers[publishers[i]] = isWhitelisted[i];\n            emit PublisherWhitelisted(publishers[i], isWhitelisted[i]);\n        }\n    }\n\n    /**\n     * @inheritdoc IEOFeedManager\n     */\n    // Reentrancy is not an issue because _feedVerifier is set by the owner\n    // slither-disable-next-line reentrancy-benign,reentrancy-events\n    function updateFeed(\n        IEOFeedVerifier.LeafInput calldata input,\n        IEOFeedVerifier.VerificationParams calldata vParams\n    )\n        external\n        onlyWhitelisted\n        whenNotPaused\n    {\n        bytes memory data = _feedVerifier.verify(input, vParams);\n        _processVerifiedRate(data, vParams.blockNumber);\n    }\n\n    /**\n     * @inheritdoc IEOFeedManager\n     */\n    // Reentrancy is not an issue because _feedVerifier is set by the owner\n    // slither-disable-next-line reentrancy-benign,reentrancy-events\n    function updateFeeds(\n        IEOFeedVerifier.LeafInput[] calldata inputs,\n        IEOFeedVerifier.VerificationParams calldata vParams\n    )\n        external\n        onlyWhitelisted\n        whenNotPaused\n    {\n        if (inputs.length == 0) revert MissingLeafInputs();\n\n        bytes[] memory data = _feedVerifier.batchVerify(inputs, vParams);\n        for (uint256 i = 0; i < data.length; i++) {\n            _processVerifiedRate(data[i], vParams.blockNumber);\n        }\n    }\n\n    /**\n     * @notice Set the pauser registry contract address\n     * @param pauserRegistry Address of the pauser registry contract\n     */\n    function setPauserRegistry(address pauserRegistry) external onlyOwner onlyNonZeroAddress(pauserRegistry) {\n        _pauserRegistry = IPauserRegistry(pauserRegistry);\n        emit PauserRegistrySet(pauserRegistry);\n    }\n\n    /**\n     * @notice Pause the feed manager\n     */\n    function pause() external onlyPauser {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause the feed manager\n     */\n    function unpause() external onlyUnpauser {\n        _unpause();\n    }\n\n    /**\n     * @inheritdoc IEOFeedManager\n     */\n    function getLatestPriceFeed(uint256 feedId) external view returns (PriceFeed memory) {\n        return _getLatestPriceFeed(feedId);\n    }\n\n    /**\n     * @inheritdoc IEOFeedManager\n     */\n    function getLatestPriceFeeds(uint256[] calldata feedIds) external view returns (PriceFeed[] memory) {\n        PriceFeed[] memory retVal = new PriceFeed[](feedIds.length);\n        for (uint256 i = 0; i < feedIds.length; i++) {\n            retVal[i] = _getLatestPriceFeed(feedIds[i]);\n        }\n        return retVal;\n    }\n\n    /**\n     * @inheritdoc IEOFeedManager\n     */\n    function isWhitelistedPublisher(address publisher) external view returns (bool) {\n        return _whitelistedPublishers[publisher];\n    }\n\n    /**\n     * @inheritdoc IEOFeedManager\n     */\n    function isSupportedFeed(uint256 feedId) external view returns (bool) {\n        return _supportedFeedIds[feedId];\n    }\n\n    /**\n     * @inheritdoc IEOFeedManager\n     */\n    function getFeedDeployer() external view returns (address) {\n        return _feedDeployer;\n    }\n\n    /**\n     * @inheritdoc IEOFeedManager\n     */\n    function getFeedVerifier() external view returns (IEOFeedVerifier) {\n        return _feedVerifier;\n    }\n\n    /**\n     * @inheritdoc IEOFeedManager\n     */\n    function getPauserRegistry() external view returns (IPauserRegistry) {\n        return _pauserRegistry;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * @notice Process the verified feed data, validate it and store it. If the timestamp is newer than the\n     *  existing timestamp, updates the price feed and emits RateUpdated. Otherwise emits SymbolReplay without updating.\n     * @param data verified feed data, abi encoded (uint256 feedId, uint256 rate, uint256 timestamp)\n     * @param blockNumber eoracle chain block number\n     */\n    function _processVerifiedRate(bytes memory data, uint256 blockNumber) internal {\n        (uint256 feedId, uint256 rate, uint256 timestamp) = abi.decode(data, (uint256, uint256, uint256));\n        if (!_supportedFeedIds[feedId]) revert FeedNotSupported(feedId);\n        if (_priceFeeds[feedId].timestamp < timestamp) {\n            _priceFeeds[feedId] = PriceFeed(rate, timestamp, blockNumber);\n            emit RateUpdated(feedId, rate, timestamp);\n        } else {\n            emit SymbolReplay(feedId, rate, timestamp, _priceFeeds[feedId].timestamp);\n        }\n    }\n\n    /**\n     * @notice Get the latest price feed\n     * @param feedId Feed id\n     * @return PriceFeed struct\n     */\n    function _getLatestPriceFeed(uint256 feedId) internal view returns (PriceFeed memory) {\n        if (!_supportedFeedIds[feedId]) revert FeedNotSupported(feedId);\n        return _priceFeeds[feedId];\n    }\n\n    /**\n     * @dev Gap for future storage variables in upgradeable contract.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    // solhint-disable ordering\n    // slither-disable-next-line unused-state,naming-convention\n    uint256[48] private __gap;\n    // solhint-disable enable\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/utils/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Pausable\n    struct PausableStorage {\n        bool _paused;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Pausable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;\n\n    function _getPausableStorage() private pure returns (PausableStorage storage $) {\n        assembly {\n            $.slot := PausableStorageLocation\n        }\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        PausableStorage storage $ = _getPausableStorage();\n        return $._paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        PausableStorage storage $ = _getPausableStorage();\n        $._paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "lib/eigenlayer-contracts/src/contracts/interfaces/IPauserRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\n/**\n * @title Interface for the `PauserRegistry` contract.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n */\ninterface IPauserRegistry {\n    event PauserStatusChanged(address pauser, bool canPause);\n\n    event UnpauserChanged(address previousUnpauser, address newUnpauser);\n\n    /// @notice Mapping of addresses to whether they hold the pauser role.\n    function isPauser(address pauser) external view returns (bool);\n\n    /// @notice Unique address that holds the unpauser role. Capable of changing *both* the pauser and unpauser addresses.\n    function unpauser() external view returns (address);\n}\n"
    },
    "src/interfaces/IEOFeedVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\n/**\n * @title IEOFeedVerifier\n * @author eOracle\n */\ninterface IEOFeedVerifier {\n    /* ============ Structs ============ */\n\n    /**\n     * @dev Input data for leaf verification\n     * @param leafIndex Index of the leaf\n     * @param unhashedLeaf Unhashed leaf data\n     *         abi encoded (uint256 feedId, uint256 rate, uint256 timestamp)\n     * @param proof Merkle proof of the leaf\n     */\n    struct LeafInput {\n        uint256 leafIndex;\n        bytes unhashedLeaf;\n        bytes32[] proof;\n    }\n\n    /**\n     * @dev Signed Data structure\n     * @param eventRoot merkle tree root for events\n     * @param blockNumber the block number this merkle tree originated from (on EO chain)\n     * @param signature G1 hashed payload of abi.encode(eventRoot, blockNumber)\n     * @param apkG2 G2 apk provided from off-chain\n     * @param nonSignersBitmap used to construct G1 apk onchain\n     */\n    struct VerificationParams {\n        uint64 blockNumber; // 8 bytes +\n        uint32 chainId; // 4 bytes +\n        address aggregator; // 20 bytes = 32 bytes\n        bytes32 eventRoot; // 32 bytes\n        bytes32 blockHash; // 32 bytes\n        uint256[2] signature; // 64 bytes\n        uint256[4] apkG2; // 128 bytes\n        bytes nonSignersBitmap; // dynamic\n    }\n\n    /**\n     * @notice Represents a validator in the system\n     * @param _address The validator's address\n     * @param g1pk validator G1 public key\n     * @param g2pk validator G2 public key (not used in current implementation)\n     * @param votingPower Validator voting power\n     */\n    struct Validator {\n        address _address;\n        uint256[2] g1pk;\n        uint256[4] g2pk;\n        uint256 votingPower;\n    }\n\n    /* ============ Events ============ */\n\n    /**\n     * @dev Event emitted when the validator set is updated\n     * @param currentValidatorSetLength Length of the current validator set\n     * @param currentValidatorSetHash Hash of the current validator set\n     * @param totalVotingPower Total voting power of the current validator set\n     */\n    event ValidatorSetUpdated(\n        uint256 currentValidatorSetLength, bytes32 currentValidatorSetHash, uint256 totalVotingPower\n    );\n\n    /**\n     * @dev Event emitted when the feed manager is set\n     * @param feedManager Address of the feed manager\n     */\n    event FeedManagerSet(address feedManager);\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @notice verify single leaf signature from a block merkle tree\n     * @param input leaf input data and proof (LeafInput)\n     * @param vParams verification params\n     * @return leafData Leaf data, abi encoded (uint256 feedId, uint256 rate, uint256 timestamp)\n     */\n    function verify(\n        LeafInput memory input,\n        VerificationParams calldata vParams\n    )\n        external\n        returns (bytes memory leafData);\n\n    /**\n     * @notice batch verify signature of multiple leaves from the same block merkle tree\n     * @param inputs feed leaves\n     * @param vParams verification params\n     */\n    function batchVerify(\n        LeafInput[] memory inputs,\n        VerificationParams calldata vParams\n    )\n        external\n        returns (bytes[] memory);\n}\n"
    },
    "src/interfaces/IEOFeedManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\nimport { IEOFeedVerifier } from \"./IEOFeedVerifier.sol\";\nimport { IPauserRegistry } from \"eigenlayer-contracts/interfaces/IPauserRegistry.sol\";\n\n/**\n * @title IEOFeedManager\n * @author eOracle\n */\ninterface IEOFeedManager {\n    /* ============ Structs ============ */\n\n    /**\n     * @dev Price feed structure\n     * @param value Price feed value\n     * @param timestamp Price feed timestamp (block timestamp in eoracle chain when price feed rate is aggregated)\n     * @param eoracleBlockNumber eoracle block number\n     */\n    struct PriceFeed {\n        uint256 value;\n        uint256 timestamp;\n        uint256 eoracleBlockNumber;\n    }\n\n    /* ============ Events ============ */\n\n    /**\n     * @dev Event emitted when a price feed is updated\n     * @param feedId Feed id\n     * @param rate Price feed value\n     * @param timestamp Price feed timestamp\n     */\n    event RateUpdated(uint256 indexed feedId, uint256 rate, uint256 timestamp);\n\n    /**\n     * @dev Event emitted when a price feed is replayed\n     * @param feedId Feed id\n     * @param rate Price feed value\n     * @param timestamp Price feed timestamp\n     * @param latestTimestamp Latest price feed timestamp\n     */\n    event SymbolReplay(uint256 indexed feedId, uint256 rate, uint256 timestamp, uint256 latestTimestamp);\n\n    /**\n     * @dev Event emitted when the feed deployer is set\n     * @param feedDeployer Address of the feed deployer\n     */\n    event FeedDeployerSet(address indexed feedDeployer);\n\n    /**\n     * @dev Event emitted when the feed verifier is set\n     * @param feedVerifier Address of the feed verifier\n     */\n    event FeedVerifierSet(address indexed feedVerifier);\n\n    /**\n     * @dev Event emitted when the pauser registry is set\n     * @param pauserRegistry Address of the pauser registry\n     */\n    event PauserRegistrySet(address indexed pauserRegistry);\n\n    /**\n     * @dev Event emitted when the supported feeds are updated\n     * @param feedId Feed id\n     * @param isSupported Boolean indicating whether the feed is supported\n     */\n    event SupportedFeedsUpdated(uint256 indexed feedId, bool isSupported);\n\n    /**\n     * @dev Event emitted when a publisher is whitelisted\n     * @param publisher Address of the publisher\n     * @param isWhitelisted Boolean indicating whether the publisher is whitelisted\n     */\n    event PublisherWhitelisted(address indexed publisher, bool isWhitelisted);\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @notice Update the price for a feed\n     * @param input A merkle leaf containing price data and its merkle proof\n     * @param vParams Verification parameters\n     */\n    function updateFeed(\n        IEOFeedVerifier.LeafInput calldata input,\n        IEOFeedVerifier.VerificationParams calldata vParams\n    )\n        external;\n\n    /**\n     * @notice Update the price for multiple feeds\n     * @param inputs Array of leafs to prove the price feeds\n     * @param vParams Verification parameters\n     */\n    function updateFeeds(\n        IEOFeedVerifier.LeafInput[] calldata inputs,\n        IEOFeedVerifier.VerificationParams calldata vParams\n    )\n        external;\n\n    /**\n     * @notice Whitelist or remove publishers\n     * @param publishers Array of publisher addresses\n     * @param isWhitelisted Array of booleans indicating whether each publisher should be whitelisted\n     */\n    function whitelistPublishers(address[] calldata publishers, bool[] calldata isWhitelisted) external;\n\n    /**\n     * @notice Get the latest price for a feed\n     * @param feedId Feed id\n     * @return The latest price feed data containing:\n     *         - value: The price feed value\n     *         - timestamp: The timestamp when the price was aggregated\n     *         - eoracleBlockNumber: The eoracle block number when the price was recorded\n     */\n    function getLatestPriceFeed(uint256 feedId) external view returns (PriceFeed memory);\n\n    /**\n     * @notice Get the latest price feeds for multiple feeds\n     * @param feedIds Array of feed ids\n     * @return Array of PriceFeed structs corresponding to each requested feed ID\n     */\n    function getLatestPriceFeeds(uint256[] calldata feedIds) external view returns (PriceFeed[] memory);\n\n    /**\n     * @notice Check if a publisher is whitelisted\n     * @param publisher Address of the publisher\n     * @return Boolean indicating whether the publisher is whitelisted\n     */\n    function isWhitelistedPublisher(address publisher) external view returns (bool);\n\n    /**\n     * @notice Check if a feed is supported\n     * @param feedId feed Id to check\n     * @return Boolean indicating whether the feed is supported\n     */\n    function isSupportedFeed(uint256 feedId) external view returns (bool);\n\n    /**\n     * @notice Get the feed deployer\n     * @return Address of the feed deployer\n     */\n    function getFeedDeployer() external view returns (address);\n\n    /**\n     * @notice Get the feed verifier contract address\n     * @return Address of the feed verifier contract\n     */\n    function getFeedVerifier() external view returns (IEOFeedVerifier);\n\n    /**\n     * @notice Get the pauser registry contract address\n     * @return Address of the pauser registry contract\n     */\n    function getPauserRegistry() external view returns (IPauserRegistry);\n}\n"
    },
    "src/interfaces/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                EOFeedManager\n//////////////////////////////////////////////////////////////////////////*/\nerror CallerIsNotWhitelisted(address caller);\nerror MissingLeafInputs();\nerror FeedNotSupported(uint256 feedId);\nerror CallerIsNotPauser();\nerror CallerIsNotUnpauser();\nerror CallerIsNotFeedDeployer();\n/*//////////////////////////////////////////////////////////////////////////\n                                EOFeedVerifier\n//////////////////////////////////////////////////////////////////////////*/\nerror CallerIsNotFeedManager();\nerror InvalidInput();\nerror InvalidProof();\nerror InvalidAddress();\nerror InvalidEventRoot();\nerror VotingPowerIsZero();\nerror InsufficientVotingPower();\nerror SignatureVerificationFailed();\nerror SignaturePairingFailed();\nerror ValidatorIndexOutOfBounds();\nerror ValidatorSetTooSmall();\nerror DuplicatedAddresses();\n\n/*//////////////////////////////////////////////////////////////////////////\n                                EOFeedRegistryAdapter\n//////////////////////////////////////////////////////////////////////////*/\nerror FeedAlreadyExists();\nerror BaseQuotePairExists();\nerror FeedDoesNotExist();\nerror NotFeedDeployer();\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
      "ds-test/=lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "forge-safe/=lib/forge-safe/src/",
      "eigenlayer-contracts/=lib/eigenlayer-contracts/src/contracts/",
      "@openzeppelin-upgrades-v4.9.0/=lib/eigenlayer-contracts/lib/openzeppelin-contracts-upgradeable-v4.9.0/",
      "@openzeppelin-upgrades/=lib/eigenlayer-contracts/lib/openzeppelin-contracts-upgradeable/",
      "@openzeppelin-v4.9.0/=lib/eigenlayer-contracts/lib/openzeppelin-contracts-v4.9.0/",
      "erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/",
      "openzeppelin-contracts-upgradeable-v4.9.0/=lib/eigenlayer-contracts/lib/openzeppelin-contracts-upgradeable-v4.9.0/",
      "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/",
      "openzeppelin-contracts-v4.9.0/=lib/eigenlayer-contracts/lib/openzeppelin-contracts-v4.9.0/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "openzeppelin-foundry-upgrades/=lib/openzeppelin-foundry-upgrades/src/",
      "openzeppelin/=lib/eigenlayer-contracts/lib/openzeppelin-contracts-upgradeable-v4.9.0/contracts/",
      "solidity-stringutils/=lib/openzeppelin-foundry-upgrades/lib/solidity-stringutils/",
      "solmate/=lib/forge-safe/lib/solmate/src/",
      "surl/=lib/forge-safe/lib/surl/",
      "zeus-templates/=lib/eigenlayer-contracts/lib/zeus-templates/src/"
    ],
    "optimizer": { "enabled": true, "runs": 10000 },
    "metadata": { "useLiteralContent": false, "bytecodeHash": "none", "appendCBOR": true },
    "outputSelection": {
      "*": {
        "": ["ast"],
        "*": [
          "abi",
          "evm.bytecode.object",
          "evm.bytecode.sourceMap",
          "evm.bytecode.linkReferences",
          "evm.deployedBytecode.object",
          "evm.deployedBytecode.sourceMap",
          "evm.deployedBytecode.linkReferences",
          "evm.deployedBytecode.immutableReferences",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout"
        ]
      }
    },
    "evmVersion": "paris",
    "viaIR": false,
    "libraries": {}
  }
}
